# 垃圾收集器与内存分配策略
## 概述
垃圾收集（GC）关注的是JAVA堆中内存的自动回收问题：
1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收
内存分配时指如何决定新建对象生成的位置，特别是当同时进行GC时。
## 哪些内存需要回收？
垃圾收集器回收的时候第一件事情就是确认哪些对象还存活着，哪些已经死去（即对象不会再被使用）。
### 引用计数法
类似C++智能指针的实现方式，为每个对象维护一个计数器，当对象被引用的时候，计数器加一，计数器为0的时候代表对象已死。优势在于实现简单，劣势在于难以解决循环引用等问题。
### 可达性分析算法
通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。
![](https://img-blog.csdnimg.cn/20200616111953785.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5MTcyMw==,size_16,color_FFFFFF,t_70#pic_left)
可作为GC Roots的对象：
1. 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象
5. 等等
### JAVA中的引用
不同的对象引用类型， GC 会采用不同的方法进行回收，JVM 对象的引用分为了四种类型：
1. 强引用：类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。
2. 软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
3. 弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
4. 虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
无论引用计数算法还是可达性分析算法都是基于强引用而言的。
### finalize（）相关
### 回收方法区
## 垃圾回收算法
### 分代收集理论
弱分代假说：大部分对象朝生夕死，保存在新生代，频繁进行GC
强分代假说：熬过越多次垃圾收集过程中的对象就越难以消亡，熬过一定次数GC的对象放入老年代
### 标记-清除算法
标记—清除算法是最基础的收集算法，它分为 “标记” 和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的可达性分析算法中判定垃圾对象的标记过程。标记—清除算法的执行情况如下图所示：
![](https://img-blog.csdnimg.cn/20200616120336983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5MTcyMw==,size_16,color_FFFFFF,t_70#pic)
主要缺点：
1. 一个是效率问题，标记和清除过程的效率都不高。
2. 内存碎片
### 标记-复制算法
为了解决 Mark-Sweep 算法的缺陷，Copying 算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。
![](https://imgconvert.csdnimg.cn/aHR0cDovL3BpY3R1cmUudGp0dWxvbmcudG9wLyVFNSVBNCU4RCVFNSU4OCVCNiVFNyVBRSU5NyVFNiVCMyU5NS5KUEc)
IBM 公司的专门研究表明，新生代中的对象 98% 是 “朝生夕死” 的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性的复制到另外一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性的复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。
![](https://imgconvert.csdnimg.cn/aHR0cDovL3BpY3R1cmUudGp0dWxvbmcudG9wL0VkZW4uSlBH)
### 标记-整理算法
为了解决 Copying 算法的缺陷，充分利用内存空间，提出了 Mark-Compact 算法。该算法标记阶段和 Mark-Sweep 一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
![](https://img-blog.csdnimg.cn/20200616121613445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5MTcyMw==,size_16,color_FFFFFF,t_70#pic)

### 分代收集算法
当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代。
在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，
而老年代中**因为对象存活率高、没有额外空间对它进行分配担保**，就必须使用标记—清除算法或标记—整理算法来进行回收。
1. 年轻代的垃圾收集算法
   在年轻代中 jvm 使用的是复制算法，年轻代分三个区。
   一个 Eden 区，两个 Survivor 区 (一般而言)。大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象将被复制到 Survivor 区（两个中的一个），当这个 Survivor 区满时，此区的存活对象将被复制到另外一个 Survivor 区，当另外一个 Survivor 区也满了的时候，从第一个 Survivor 区复制过来的并且此时还存活的对象，将被复制到 “年老区 (Tenured)”。需要注意，Survivor 的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 Eden 复制过来对象，和从前一个 Survivor 复制过来的对象，而复制到年老区的只有从第一个 Survivor 区过来的对象。而且，Survivor 区总有一个是空的。
   当 survivor1 区不足以存放 eden 和 survivor0 的存活对象时，就将存活对象直接存放到老年代**担保机制**。

   新生代 GC（Minor GC）：发生在新生代的垃圾收集动作，因为 Java 对象大多都具有朝生夕灭的特性，因此 Minor GC 非常频繁，一般回收速度也比较快。
2. 老年代的回收算法
   老年代的特点是每次回收都只回收少量对象，一般使用的是 Mark-Compact（标记 - 整理）算法。
   在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
   内存比新生代也大很多 (大概比例是 1:2)，当老年代内存满时触发 Major GC 或 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率标记高。

    老年代 GC（Major GC/Full GC）：发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次 Minor GC。由于老年代中的对象生命周期比较长，因此 Major GC 并不频繁，一般都是等待老年代满了后才进行 Full GC，而且其速度一般会比 Minor GC 慢 10 倍以上。另外，如果分配了 Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。
### 垃圾回收的时机
1. 当 Eden 区或者 Servior 区不够用了
2. 老年代空间不够用了
3. 方法区空间不够用了
4. 手动回收，System.gc()（不建议使用）
   
### HotSpot的算法细节实现
<!-- #### 根节点枚举 -->
1. 枚举根节点：可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。执行根节点枚举需要stop the world。
2. 安全点：安全点是在程序执行期间的所有GC Root已知并且所有堆对象的内容一致的点。所有线程必须在GC运行之前在安全点阻塞。
3. 安全区域：在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
4. 记忆集与卡表：解决对象跨代引用问题，年轻代会有一个字节数组记录老年代哪些区域有引用年轻代对象。
5. 写屏障：类似AOP，对对象更改后更新卡表
6. 并发的可达性分析：三色理论，增量更新和SATB
   
## 垃圾回收器
### 

