# 基础构建模块
## 同步容器类
* 同步容器类包括Vector、Hashtable。同步容器类实现同步的方法是将它们的状态封装起来，并对每个公有方法进行加锁。
* 同步容器类是线程安全的，但是需要客户端加锁保护复合操作，比如迭代，若没有则增加
* 效率低
* 同步容器类在使用迭代器迭代时如果被修改了，会抛出ConcurrentModificationException（fail-fast机制），CopyOnWriteArrayList使用写时复制避免了这个问题。
* 虽然加锁可以防止迭代器抛出ConcurrentModificationException，但你必须要记住在所有对共享容器进行迭代的地方都需要加锁。 然而实际情况要更加复杂，因为在某些情况下，迭代器会隐藏起来。比如toString方法，hashCode、equals等方法。
## 并发容器
### ConcurrentHashMap
* CAS + 锁实现并发，锁的粒度很小，数组上每个元素一个锁。参考https://juejin.cn/post/7064061605185028110
* 写需要加锁，读因为node使用volatile修饰，不需要加锁
* 扩容时链表是在新表直接new份新节点，并且全部复制完毕才更改头节点，所以读仍然不需要加锁。
* 迁移时每个线程分到不同桶
* 使用CounterCell[] 统计数量类似addrLong原理
* 不允许插入null元素，因为无法判断是否映射为null还是从未插入，其他并行容器好像都是类似。hashmap可以插入null，因为可以通过containKey判断。
### CopyOnWriteArrayList
* 读不需要加锁，效率很高
* 写需要加锁，且需要复制整个数组，效率低
### BlockingQueue
#### ArrayBlockingQueue
* 有界阻塞队列, 底层是一个数组
* 使用一个全局锁+两个条件变量保证并行
* take和put都需要对同一个全局锁进行加锁，无法并行，然后notify()不是notifyAll()唤醒对应的条件变量（take对应notFull()）。
#### LinkedBlockingQueue
* 可以是有界、无界阻塞队列，底层数据结构是一个链表,不支持公平性
* 使用两个锁+两个条件变量+一个ActomicInteger记录元素数量
* 读写分别对take锁和put锁进行加锁，并更新元素数量, 理论上并行更高
* take的时候，会根据队列中是否有元素使用notify()唤醒notEmpty()和notFull() （需要唤醒notEmpty的原因是,现在take和put可以并行，存在notFull信号丢失问题，比如take刚刚发完notFull之后，立刻就有线程阻塞在notfull）
#### PriorityBlockingQueue
* 底层是数组的堆（优先队列），无界
* 使用一个全局锁+一个条件变量保护并发，take和put不可以并行
* 具有优先级
#### DelayQueue
* 无界，底层是优先队列，类似于PriorityBlockingQueue
* 不同点在于，take的时候，线程分为leader和follow，只有leader可以take，其他要等待，leader线程take元素之后，会清除自身的leader身份，这么做的原因是最小化等待时间，因为leader元素必须查看队列头部元素，并查看到期时间之后才能决定需要等待多久。
#### SynchronousQueue
* 特点是底层无数据结构，有公平和非公平两种模式
* take线程如果没有put线程配对，会一直阻塞。反过来也是这样。
* 公平模式线程类似链表排队，非公平模式类似栈
#### LinkedTransferQueue
* 像是SynchronousQueue+LinkedBlockingQUeue
* 无界，无锁并发队列
* 同时提供类似SynchronousQueue的transfer方法和LinkedBlockingQUeue的put方法
#### LinkedBlockingDeque
* 两端读写，底层是链表
* 一个全局锁+两个全局变量，类似ArrayBlockingQueue
* 适合工作密取

## 中断方法
* 中断实际上是一种协作,interrupt()方法实际上只设置了标记为
* 等待锁时一般不响应中断
* catch到中断异常时要么不处理，直接抛出，要么再次调用interrupt()恢复异常标记，因为一般像wait()方法中断抛出异常后会清楚异常标记

## FutureTask实现原理
* 使用状态控制任务的完成情况
* 调用get等待结果的线程会形成一个简单的无锁栈Treiber
* 可以中断